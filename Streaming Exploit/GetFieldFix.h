#pragma once
#include "stdafx.h"
#pragma once

/* Includes */

#include <windows.h>
#include <vector>
#include <sstream>
//#include "VMProtectSDK.h"

bool QuickCompare(const BYTE *pData, const BYTE *bMask, const char *szMask) {
	for (; *szMask; ++szMask, ++pData, ++bMask)
		if (*szMask == 'x' && *pData != *bMask) return 0;
	return (*szMask) == NULL;
}

int QuickFindPattern(int dwAddress, int dwLen, BYTE *bMask, const char *szMask) {
	for (std::size_t i = 0; i<(int)dwLen; i++)
		if (QuickCompare((BYTE*)(dwAddress + (int)i), bMask, szMask))  return (int)(dwAddress + i);
	return 0;
}

int Scan(DWORD mode, char* content, char* mask)
{
	//VMProtectBeginUltra("Scan");
	DWORD PageSize;
	SYSTEM_INFO si;
	GetSystemInfo(&si);
	PageSize = si.dwPageSize;
	MEMORY_BASIC_INFORMATION mi;
	for (DWORD lpAddr = 0; lpAddr<0x7FFFFFFF; lpAddr += PageSize)
	{
		DWORD vq = VirtualQuery((void*)lpAddr, &mi, PageSize);
		if (vq == ERROR_INVALID_PARAMETER || vq == 0) break;
		if (mi.Type == MEM_MAPPED) continue;
		if (mi.Protect == mode)
		{
			int addr = QuickFindPattern(lpAddr, PageSize, (PBYTE)content, mask);
			if (addr != 0)
			{
				return addr;
			}
		}
	}
	//VMProtectEnd();
}

DWORD Unprotect(DWORD addr)
{
	DWORD alloc = 0;

	BYTE* tAddr = (BYTE*)addr;

	do {
		tAddr += 0x10;
	} while (!(tAddr[0] == 0x55 && tAddr[1] == 0x8B && tAddr[2] == 0xEC));

	DWORD funcSz = tAddr - (BYTE*)addr;

	alloc += funcSz;
	if (alloc > 0x100000)
		return addr;

	PVOID nFunc = VirtualAlloc(NULL, funcSz, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (nFunc == NULL)
		return addr;

	memcpy(nFunc, (BYTE*)addr, funcSz);

	DWORD pos = (DWORD)nFunc;
	BOOL valid = false;
	do {
		if (*(BYTE*)pos == 0x72 && *(BYTE*)(pos + 0x2) == 0xA1 && *(BYTE*)(pos + 0x7) == 0x8B) {
			DWORD oProtect;
			VirtualProtect((void*)pos, 5, PAGE_EXECUTE_READWRITE, &oProtect);
			*(BYTE*)pos = 0xEB;
			VirtualProtect((void*)pos, 5, oProtect, &oProtect);

			DWORD cNFunc = (DWORD)nFunc;
			do {
				if (*(BYTE*)cNFunc == 0xE8)
				{
					DWORD tFunc = addr + (cNFunc - (DWORD)nFunc);
					DWORD oFunc = (tFunc + *(DWORD*)(tFunc + 1)) + 5;

					if (oFunc % 16 == 0)
					{
						DWORD rebFAddr = oFunc - cNFunc - 5;
						memcpy((PVOID)(cNFunc + 1), &rebFAddr, 4);
					}
				}
				cNFunc += 1;
			} while (cNFunc - (DWORD)nFunc < funcSz);

			valid = true;
		}
		pos += 1;
	} while (pos < (DWORD)nFunc + funcSz);

	if (!valid) {
		VirtualFree(nFunc, funcSz, MEM_RELEASE);
		return addr;
	}

	return (DWORD)nFunc;
}

namespace SignatureScanner {

	int Scan(const char* arrayofbytes, const char* mask) {
		for (int i = (int)GetModuleHandle(NULL); i <= 0xF000000; ++i) {
			if (QuickCompare((BYTE*)i, (BYTE*)arrayofbytes, mask))
				return i;
		}
		return NULL;
	};

}

DWORD based = (DWORD)GetModuleHandle("RobloxPlayerBeta.exe");
DWORD getaddyz(int address) {
	return (address - 0x400000 + based);
}

int GETFIELD_ADDRESS; //Unprotect(SignatureScanner::Scan("\x55\x8B\xEC\x83\xEC\x10\x53\x56\x8B\x75\x08\x57\xFF\x75\x0C\x56\xE8\x00\x00\x00\x00\x8B\x55\x10\x83\xC4\x08\x8B\xCA\x8B\xF8\x8D\x59\x01\x8A\x01\x41\x84\xC0\x75\xF9\x2B\xCB\x51\x52\x56\xE8\x00\x00\x00\x00\xFF\x76\x10", "xxxxxxxxxxxxxxxxx????xxxxxxxxxxxxxxxxxxxxxxxxxx????xxx"));