// Streaming Exploit.cpp : Defines the exported functions for the DLL application.
//
#define _CRT_SECURE_NO_WARNINGS
#include "stdafx.h"
#include "Includes.h"
#include "stdafx.h"
#include <Windows.h>
#include <iostream>
#include <string>
#include <fstream>
#include <iterator>
#include <vector>
#include <sstream>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <WinINet.h>
#include <algorithm>
#include <random>
#include <typeinfo>
#include <wingdi.h>
#include <Windows.h>
#include <iostream>
#include <string>
#include <thread>
#include <vector>
#include <istream>
#include <iterator>
#include <sstream>
#include <Windows.h>
#include <WinInet.h>
#include <fstream>
#include <algorithm>
#include <Psapi.h>
#include <tlhelp32.h>
#include <math.h>
#include <cmath>
#include <Windows.h>
#include <iostream>
#include <string>
#include <vector>
#include <time.h>
#include <sstream>
#include <ostream>
#include <chrono>
#include <WinINet.h>
#include <algorithm>
#include <random>
#include <typeinfo>
#include <fcntl.h>
#include <io.h>
#include <iterator>
#include <TlHelp32.h>
#include <urlmon.h>
#include <stdio.h>
#include "Includes.h"
#include "Roblox Lua.h"
#define WRITABLE (PAGE_READWRITE | PAGE_WRITECOPY |PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY)

using namespace std;

static int scriptcontext, rstate;

std::vector<std::string> split(std::string s) {
	std::vector<std::string> elems;
	std::stringstream ss(s);
	std::istream_iterator<std::string> begin(ss);
	std::istream_iterator<std::string> end;
	std::vector<std::string> vstrings(begin, end);
	return vstrings;
}

string Input() {
	string in;
	getline(cin, in);
	return in;
}

void ConsoleHacks()
{
	DWORD nothing;
	VirtualProtect((PVOID)&FreeConsole, 1, PAGE_EXECUTE_READWRITE, &nothing);
	*(BYTE*)(&FreeConsole) = 0xC3;
}

void Console(char* title) {
	AllocConsole();
	SetConsoleTitleA(title);
	freopen("CONOUT$", "w", stdout);
	freopen("CONIN$", "r", stdin);
	HWND ConsoleHandle = GetConsoleWindow();
}

void testthingy(const char* msg) {
	std::cout << msg << std::endl;
}

namespace Memory {
	bool Compare(const BYTE *pData, const BYTE *bMask, const char *szMask)
	{
		for (; *szMask; ++szMask, ++pData, ++bMask)
			if (*szMask == 'x' && *pData != *bMask) return 0;
		return (*szMask) == NULL;
	}

	DWORD FindPattern(DWORD dwAddress, DWORD dwLen, BYTE *bMask, char *szMask)
	{
		for (int i = 0; i<(int)dwLen; i++)
			if (Compare((BYTE*)(dwAddress + (int)i), bMask, szMask))  return (int)(dwAddress + i);
		return 0;
	}

	DWORD FastScan(char* content)
	{
		SYSTEM_INFO SystemInfo;
		GetSystemInfo(&SystemInfo);
		DWORD PageSize = SystemInfo.dwPageSize;
		MEMORY_BASIC_INFORMATION meminfo;
		DWORD Start = (DWORD)SystemInfo.lpMinimumApplicationAddress;
		DWORD End = (DWORD)SystemInfo.lpMaximumApplicationAddress;
		for (DWORD lpAddress = Start; lpAddress <= End; lpAddress += PageSize)
		{
			VirtualQuery((void*)lpAddress, &meminfo, PageSize);
			if (meminfo.Type == MEM_MAPPED) continue;
			if (meminfo.Protect == PAGE_READWRITE) {
				DWORD Address = FindPattern(lpAddress, PageSize, (PBYTE)content, "xxxx");
				if (Address != NULL)
					return Address;
			}
		}
	}

	int Scan(DWORD mode, char* content, char* mask)
	{
		DWORD PageSize;
		SYSTEM_INFO si;
		GetSystemInfo(&si);
		PageSize = si.dwPageSize;
		MEMORY_BASIC_INFORMATION mi;
		for (DWORD lpAddr = 0; lpAddr<0x7FFFFFFF; lpAddr += PageSize)
		{
			DWORD vq = VirtualQuery((void*)lpAddr, &mi, PageSize);
			if (vq == ERROR_INVALID_PARAMETER || vq == 0) break;
			if (mi.Type == MEM_MAPPED) continue;
			if (mi.Protect == mode)
			{
				int addr = FindPattern(lpAddr, PageSize, (PBYTE)content, mask);
				if (addr != 0)
				{
					return addr;
				}
			}
		}
		return 0;
	}
}

void scan() {
	DWORD SContext = getaddy(Watch My Stream To See What This Is!);

	scriptcontext = Memory::FastScan((char*)&SContext);
	rstate = *(DWORD*)(scriptcontext + 56 * 0 + 164) - (scriptcontext + 14 * 0 + 164);
}

void Main() {
	ConsoleHacks();
	Console("Streaming Exploit Lolz!");

	testthingy("Scanning");
	scan();
	testthingy("Scanning done.");

	while (true) {
		std::cout << ">";
		vector<string>In = split(Input());
		if (In.at(0) == "print") {
			string text;
			for (int i = 1; i < In.size(); i++) {
				Watch My Stream To See What This Is!
			}
			//MBox("1");
			rl::getglobal(rstate, "print");
			//MBox("2");
			rl::pushstring(rstate, text.c_str());
			//MBox("3");
			rl::pcall(rstate, 1, 0, 0);
			//MBox("4");
		}

		else if (In.at(0) == "warn") {
			string text;
			for (int i = 1; i < In.size(); i++) {
				Watch My Stream To See What This Is!
			}
			//MBox("1");
			rl::getglobal(rstate, "warn");
			//MBox("2");
			rl::pushstring(rstate, text.c_str());
			//MBox("3");
			rl::pcall(rstate, 1, 0, 0);
			//MBox("4");
		}
	}
}

BOOL WINAPI DllMain(HINSTANCE hModule, DWORD dwReason, LPVOID lpReserved) {
	DisableThreadLibraryCalls(hModule);
	if (dwReason == DLL_PROCESS_ATTACH) {
		HANDLE hThread = NULL;
		HANDLE hDllMainThread = OpenThread(THREAD_ALL_ACCESS, NULL, GetCurrentThreadId());
		if (lpReserved == NULL) {
			if (!(hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)Main, 0, 0, 0))) {
				CloseHandle(hDllMainThread);
				return FALSE;
			}
			CloseHandle(hThread);
		}
		else if (dwReason == DLL_PROCESS_DETACH) {}
		return TRUE;
	}
}